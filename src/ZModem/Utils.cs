using System;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using ZModem.Constants;
using ZModem.CRC;

namespace ZModem
{
    public static class Utils
    {
        /// <summary>
        /// A hex header begins with the sequence ZPAD, ZPAD, ZDLE, ZHEX. 
        /// The extra ZPAD character allows the sending program to detect 
        /// an asynchronous header(indicating an error condition) and then 
        /// get the rest of the header with a non-error specific routine.
        /// </summary>
        static string HexHeader => $"{(char)ControlBytes.ZPAD}{(char)ControlBytes.ZPAD}{(char)ControlBytes.ZDLE}{(char)ControlBytes.ZHEX}";

        /// <summary>
        /// A carriage return and line feed are sent with HEX headers.
        /// The receive routine expects to see at least one of these characters,
        /// two if the first is CR.
        /// An XON character is appended to all HEX packets except ZACK and ZFIN.
        /// The XON releases the sender from spurious XOFF flow control characters
        /// generated by line noise.
        /// XON is not sent after a ZACK headers to protect flow control in streaming situations.
        /// XON is not sent after a ZFIN header to allow proper session cleanup.
        /// </summary>
        static string HexCommonHeaderEnd => $"{(char)ControlBytes.CR}{(char)ControlBytes.LF}";

        static string Bin16BitHeader => $"{(char)ControlBytes.ZPAD}{(char)ControlBytes.ZDLE}{(char)ControlBytes.ZBIN}";

        static string Bin32BitHeader => $"{(char)ControlBytes.ZPAD}{(char)ControlBytes.ZDLE}{(char)ControlBytes.ZBINC}";

        /// <summary>
        /// Build common hex frame
        /// The receiver sends responses in hex headers.
        /// The sender also uses hex headers when they are not followed by binary data subpackets.
        /// </summary>
        /// <param name="type"></param>
        /// <param name="p0"></param>
        /// <param name="p1"></param>
        /// <param name="p2"></param>
        /// <param name="p3"></param>
        /// <returns></returns>
        public static string BuildCommonHexHeader(HeaderType type, int p0, int p1, int p2, int p3, CRC16 crcCalculator)
        {
            var sb = new StringBuilder();
            sb.Append(HexHeader);
            sb.Append(((int)type).ToString("x2"));
            sb.Append(p0.ToString("x2"));
            sb.Append(p1.ToString("x2"));
            sb.Append(p2.ToString("x2"));
            sb.Append(p3.ToString("x2"));

            var crc = CRCHelper.Compute16BitHeaderAsArray((int)type, p0, p1, p2, p3, crcCalculator);

            foreach (var c in crc)
            {
                sb.Append(c.ToString("x2"));
            }

            sb.Append(HexCommonHeaderEnd);

            var command = sb.ToString();

            return command;
        }

        /// <summary>
        /// Build 16 bit binary header.
        /// 
        /// A binary header is sent by the sending program to the receiving program.All bytes in a binary header are ZDLE encoded.
        /// A binary header begins with the sequence ZPAD, ZDLE, ZBIN. 
        /// 0 or more binary data subpackets with 16 bit CRC will follow depending on the frame type.
        /// * ZDLE A TYPE F3/P0 F2/P1 F1/P2 F0/P3 CRC-1 CRC-2
        /// </summary>
        /// <param name="type"></param>
        /// <param name="p0"></param>
        /// <param name="p1"></param>
        /// <param name="p2"></param>
        /// <param name="p3"></param>
        /// <returns></returns>
        public static string Build16BitBinHeader(HeaderType type, int p0, int p1, int p2, int p3, CRC16 crcCalculator)
        {
            var sb = new StringBuilder();
            sb.Append(Bin16BitHeader);
            sb.Append(((char)(int)type).ToString());
            sb.Append(((char)p0).ToString());
            sb.Append(((char)p1).ToString());
            sb.Append(((char)p2).ToString());
            sb.Append(((char)p3).ToString());

            var crc = CRCHelper.Compute16BitHeader((int)type, p0, p1, p2, p3, crcCalculator);
            int crc1 = (crc & 0xff00) >> 8;
            int crc2 = crc & 0xff;

            sb.Append(((char)crc1).ToString());
            sb.Append(((char)crc2).ToString());

            var command = sb.ToString();

            return command;
        }

        /// <summary>
        /// Build 16 bit binary header.
        /// 
        /// A binary header is sent by the sending program to the receiving program.All bytes in a binary header are ZDLE encoded.
        /// A binary header begins with the sequence ZPAD, ZDLE, ZBIN. 
        /// 0 or more binary data subpackets with 16 bit CRC will follow depending on the frame type.
        /// * ZDLE A TYPE F3/P0 F2/P1 F1/P2 F0/P3 CRC-1 CRC-2
        /// </summary>
        /// <param name="type"></param>
        /// <param name="f0"></param>
        /// <param name="f1"></param>
        /// <param name="f2"></param>
        /// <param name="f3"></param>
        /// <returns></returns>
        public static string Build16BitBinHeader(HeaderType type, ZFILEConversionOption f0, ZFILEManagementOption f1, ZFILETransportOption f2, ZFILEExtendedOptions f3, CRC16 crcCalculator)
        {
            var sb = new StringBuilder();
            sb.Append(Bin16BitHeader);
            sb.Append(((char)(int)type).ToString());
            sb.Append(((char)f3).ToString());
            sb.Append(((char)f2).ToString());
            sb.Append(((char)f1).ToString());
            sb.Append(((char)f0).ToString());

            var b = new byte[5];
            b[0] = Convert.ToByte(type);
            b[1] = Convert.ToByte(f3);
            b[2] = Convert.ToByte(f2);
            b[3] = Convert.ToByte(f1);
            b[4] = Convert.ToByte(f0);

            var crc = CRCHelper.Compute16BitHeaderAsArray((int)type, (int)f3, (int)f2, (int)f1, (int)f0, crcCalculator);

            int crc1 = crc[1];
            int crc2 = crc[0];

            sb.Append(((char)crc1).ToString());
            sb.Append(((char)crc2).ToString());

            var command = sb.ToString();

            return command;
        }

        /// <summary>
        /// Build 32 bit binary header.
        /// 
        /// A "32 bit CRC" Binary header is similar to a Binary Header, except the 
        /// ZBIN(A) character is replaced by a ZBIN32(C) character, and four 
        /// characters of CRC are sent. 
        /// 0 or more binary data subpackets with 32 bit CRC will follow depending
        /// on the frame type. 
        /// * ZDLE C TYPE F3/P0 F2/P1 F1/P2 F0/P3 CRC-1 CRC-2 CRC-3 CRC-4
        /// </summary>
        /// <param name="type"></param>
        /// <param name="p0"></param>
        /// <param name="p1"></param>
        /// <param name="p2"></param>
        /// <param name="p3"></param>
        /// <returns></returns>
        public static string Build32BitBinHeader(HeaderType type, ZFILEConversionOption f0, ZFILEManagementOption f1, ZFILETransportOption f2, ZFILEExtendedOptions f3, CRC32 crcCalculator)
        {
            var sb = new StringBuilder();
            sb.Append(Bin32BitHeader);
            sb.Append(((char)(int)type).ToString());
            sb.Append(((char)f3).ToString());
            sb.Append(((char)f2).ToString());
            sb.Append(((char)f1).ToString());
            sb.Append(((char)f0).ToString());

            var crc = CRCHelper.Compute32BitHeaderAsArray((int)type, (int)f3, (int)f2, (int)f1, (int)f0, crcCalculator);

            foreach (char c in crc)
            {
                sb.Append(c);
            }

            var command = sb.ToString();

            return command;
        }

        /// <summary>
        /// Build 16 bit data header
        /// </summary>
        /// <param name="type"></param>
        /// <param name="p0"></param>
        /// <param name="p1"></param>
        /// <param name="p2"></param>
        /// <param name="p3"></param>
        /// <returns></returns>
        public static string Build16BitDataHeader(HeaderType type, int p0, int p1, int p2, int p3, CRC16 crcCalculator)
        {
            var sb = new StringBuilder();
            sb.Append(Bin16BitHeader);
            sb.Append((char)ControlBytes.ZDLE);
            sb.Append('J');
            sb.Append(((char)p0).ToString());
            sb.Append(((char)p1).ToString());
            sb.Append(((char)p2).ToString());
            sb.Append(((char)p3).ToString());

            var b = new byte[5];
            b[0] = Convert.ToByte(type);
            b[1] = Convert.ToByte(p0);
            b[2] = Convert.ToByte(p1);
            b[3] = Convert.ToByte(p2);
            b[4] = Convert.ToByte(p3);

            var crc = CRCHelper.Compute16BitHeaderAsArray((int)type, p0, p1, p2, p3, crcCalculator);

            var crc1 = crc[1];
            var crc2 = crc[0];

            sb.Append(((char)crc1).ToString());
            sb.Append(((char)crc2).ToString());

            var command = sb.ToString();

            return command;
        }

        /// <summary>
        /// Build 32 bit data header
        /// </summary>
        /// <param name="type"></param>
        /// <param name="p0"></param>
        /// <param name="p1"></param>
        /// <param name="p2"></param>
        /// <param name="p3"></param>
        /// <returns></returns>
        public static string Build32BitDataHeader(HeaderType type, int p0, int p1, int p2, int p3, CRC32 crcCalculator)
        {
            var sb = new StringBuilder();
            sb.Append(Bin32BitHeader);
            sb.Append((char)ControlBytes.ZDLE);
            sb.Append('J');
            sb.Append(((char)p0).ToString());
            sb.Append(((char)p1).ToString());
            sb.Append(((char)p2).ToString());
            sb.Append(((char)p3).ToString());

            var crc = CRCHelper.Compute32BitHeaderAsArray((int)type, p0, p1, p2, p3, crcCalculator);

            foreach (char c in crc)
            {
                sb.Append(c);
            }

            var command = sb.ToString();

            return command;
        }

        public static int GetIntFromHex(char one, char two)
        {
            var hexHeader = $"{one}{two}";
            var result = int.Parse(hexHeader, System.Globalization.NumberStyles.HexNumber);
            return result;
        }

        public static void GenerateZModemFileOffset(int? offset, out int p0, out int p1, out int p2, out int p3)
        {
            var parsedOffset = offset.HasValue ? offset.Value : 0;

            p0 = parsedOffset & 0xff;
            p1 = (parsedOffset >> 8) & 0xff;
            p2 = (parsedOffset >> 16) & 0xff;
            p3 = (parsedOffset >> 24) & 0xff;
        }

        public static int GetIntFromZModemOffset(int p0, int p1, int p2, int p3)
        {
            var intArray = new int[]
            {
                p0,
                p1 * (int)Math.Pow(256, 1),
                p2 * (int)Math.Pow(256, 2),
                p3 * (int)Math.Pow(256, 3)
            };

            return intArray.Sum();
        }

        private static double oldVal = 0.0;

        [ExcludeFromCodeCoverage]
        public static void WriteProgression(double val)
        {
            if (oldVal >= val)
            {
                return;
            }

            Console.WriteLine(string.Format("Progress: {0:P2}.", val));

            oldVal = val;
        }
    }
}
